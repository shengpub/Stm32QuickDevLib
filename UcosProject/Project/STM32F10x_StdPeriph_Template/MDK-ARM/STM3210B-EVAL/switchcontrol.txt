; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210b-eval\switchcontrol.o --asm_dir=.\STM3210B-EVAL\ --list_dir=.\STM3210B-EVAL\ --depend=.\stm3210b-eval\switchcontrol.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\ -I..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\STM3210B_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\Bsp -I..\MQTT -IC:\Users\gavinX\Desktop\GetWifiInfo\Project\STM32F10x_StdPeriph_Template\MDK-ARM\RTE\_STM32Project -Ie:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -Ie:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=522 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\stm3210b-eval\switchcontrol.crf ..\User\SwitchControl.c]
                          THUMB

                          AREA ||i.CalcCrc||, CODE, READONLY, ALIGN=1

                  CalcCrc PROC
;;;9      /*根据命令地址计算出命令的crc码*/
;;;10     uint8_t CalcCrc(char *arg1,int sizes)
000000  b510              PUSH     {r4,lr}
;;;11     {
;;;12     	uint8_t uiLoop = 0;
;;;13     	uint8_t ucCrcValue = arg1[0];
000002  7803              LDRB     r3,[r0,#0]
000004  2800              CMP      r0,#0                 ;11
000006  d00b              BEQ      |L1.32|
;;;14     
;;;15     	if(arg1 == NULL)
;;;16     	{
;;;17     		return 0;
;;;18     	}
;;;19     
;;;20     	if(sizes == 0 || sizes == 1)
000008  b149              CBZ      r1,|L1.30|
00000a  2901              CMP      r1,#1
00000c  d007              BEQ      |L1.30|
;;;21     	{
;;;22     		return ucCrcValue;
;;;23     	}
;;;24     	
;;;25     	for(uiLoop = 1;uiLoop < sizes;uiLoop++)
00000e  2201              MOVS     r2,#1
000010  e003              B        |L1.26|
                  |L1.18|
;;;26     	{
;;;27     		ucCrcValue ^=  arg1[uiLoop];
000012  5c84              LDRB     r4,[r0,r2]
000014  4063              EORS     r3,r3,r4
000016  1c52              ADDS     r2,r2,#1
000018  b2d2              UXTB     r2,r2                 ;25
                  |L1.26|
00001a  428a              CMP      r2,r1                 ;25
00001c  dbf9              BLT      |L1.18|
                  |L1.30|
;;;28     	}
;;;29     	
;;;30     	return ucCrcValue;
00001e  4618              MOV      r0,r3
                  |L1.32|
;;;31     }
000020  bd10              POP      {r4,pc}
;;;32     /*打开指定的锁*/
                          ENDP


                          AREA ||i.OpenALock||, CODE, READONLY, ALIGN=2

                  OpenALock PROC
;;;32     /*打开指定的锁*/
;;;33     uint16_t OpenALock(uint8_t BoardAddr,uint8_t LockAddr)
000000  b51c              PUSH     {r2-r4,lr}
;;;34     {
;;;35     	OpenBoardLock OpenBoardLockCmd;
;;;36     	
;;;37     	if(BoardAddr < 1 || BoardAddr > BOARD_NUM)
000002  1e42              SUBS     r2,r0,#1
000004  2a06              CMP      r2,#6
000006  d301              BCC      |L2.12|
;;;38     	{
;;;39     		return 0;
000008  2000              MOVS     r0,#0
;;;40     	}
;;;41     	
;;;42     	if(LockAddr < 1 || LockAddr > BOARD_LOCK_NUM)
;;;43     	
;;;44     	OpenBoardLockCmd.ucHead = OPEN_BOARD_LOCK_HEAD;
;;;45     	OpenBoardLockCmd.ucBoardAddr = BoardAddr;
;;;46     	OpenBoardLockCmd.ucLockAddr = LockAddr;
;;;47     	OpenBoardLockCmd.ucState = 0x11;
;;;48     	OpenBoardLockCmd.ucCrc = CalcCrc((char *)&OpenBoardLockCmd,(sizeof(OpenBoardLock) -1));
;;;49     	
;;;50     	USARTWrite(SWITCH_BOARD_USAET,(char *)&OpenBoardLockCmd,sizeof(OpenBoardLock));
;;;51     }
00000a  bd1c              POP      {r2-r4,pc}
                  |L2.12|
00000c  1e4a              SUBS     r2,r1,#1              ;42
00000e  2a19              CMP      r2,#0x19              ;42
000010  d302              BCC      |L2.24|
000012  228a              MOVS     r2,#0x8a              ;44
000014  f88d2000          STRB     r2,[sp,#0]            ;44
                  |L2.24|
000018  f88d0001          STRB     r0,[sp,#1]            ;45
00001c  f88d1002          STRB     r1,[sp,#2]            ;46
000020  2011              MOVS     r0,#0x11              ;47
000022  f88d0003          STRB     r0,[sp,#3]            ;47
000026  2104              MOVS     r1,#4                 ;48
000028  4668              MOV      r0,sp                 ;48
00002a  f7fffffe          BL       CalcCrc
00002e  f88d0004          STRB     r0,[sp,#4]            ;48
000032  2205              MOVS     r2,#5                 ;50
000034  4669              MOV      r1,sp                 ;50
000036  4802              LDR      r0,|L2.64|
000038  f7fffffe          BL       USARTWrite
00003c  bd1c              POP      {r2-r4,pc}
;;;52     /*打开所有的锁,管理员权限，非常危险*/
                          ENDP

00003e  0000              DCW      0x0000
                  |L2.64|
                          DCD      0x40013800

                          AREA ||i.OpenAllLock||, CODE, READONLY, ALIGN=2

                  OpenAllLock PROC
;;;52     /*打开所有的锁,管理员权限，非常危险*/
;;;53     uint16_t OpenAllLock()
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;54     {
;;;55     	uint8_t  ucLoop = 0;
;;;56     	OpenBoardLock OpenBoardLockCmd;
;;;57     	
;;;58     	for(ucLoop = 1; ucLoop < BOARD_NUM; ucLoop++)
000004  2401              MOVS     r4,#1
000006  2500              MOVS     r5,#0
;;;59     	{
;;;60     		OpenBoardLockCmd.ucHead = OPEN_BOARD_LOCK_HEAD;
000008  268a              MOVS     r6,#0x8a
;;;61     		OpenBoardLockCmd.ucBoardAddr = ucLoop;
;;;62     		OpenBoardLockCmd.ucLockAddr = 0x00;
;;;63     		OpenBoardLockCmd.ucState = 0x11;
;;;64     		OpenBoardLockCmd.ucCrc = CalcCrc((char *)&OpenBoardLockCmd,(sizeof(OpenBoardLock) -1));
;;;65     		
;;;66     		USARTWrite(SWITCH_BOARD_USAET,(char *)&OpenBoardLockCmd,sizeof(OpenBoardLock));
00000a  f8df8038          LDR      r8,|L3.68|
00000e  2711              MOVS     r7,#0x11              ;63
                  |L3.16|
000010  f88d6000          STRB     r6,[sp,#0]            ;60
000014  f88d4001          STRB     r4,[sp,#1]            ;61
000018  f88d5002          STRB     r5,[sp,#2]            ;62
00001c  f88d7003          STRB     r7,[sp,#3]            ;63
000020  2104              MOVS     r1,#4                 ;64
000022  4668              MOV      r0,sp                 ;64
000024  f7fffffe          BL       CalcCrc
000028  f88d0004          STRB     r0,[sp,#4]            ;64
00002c  2205              MOVS     r2,#5
00002e  4669              MOV      r1,sp
000030  4640              MOV      r0,r8
000032  f7fffffe          BL       USARTWrite
000036  1c64              ADDS     r4,r4,#1
000038  b2e4              UXTB     r4,r4                 ;58
00003a  2c06              CMP      r4,#6                 ;58
00003c  d3e8              BCC      |L3.16|
;;;67     	}
;;;68     }
00003e  e8bd81fc          POP      {r2-r8,pc}
;;;69     
                          ENDP

000042  0000              DCW      0x0000
                  |L3.68|
                          DCD      0x40013800

                          AREA ||i.OpenLockRspDel||, CODE, READONLY, ALIGN=1

                  OpenLockRspDel PROC
;;;77     /*开锁返回处理命令*/
;;;78     uint16_t OpenLockRspDel(OpenBoardLockRsp *aBoardLockState)
000000  b500              PUSH     {lr}
;;;79     {
;;;80     	/*打开锁后需要修改，先判断是否打开成功*/
;;;81     	if(aBoardLockState->ucState == BOARD_LOCK_OPEN_STATE)
000002  78c2              LDRB     r2,[r0,#3]
000004  2a11              CMP      r2,#0x11
000006  d001              BEQ      |L4.12|
;;;82     	{
;;;83     		SetBoardALockState(aBoardLockState->ucBoardAddr,aBoardLockState->ucLockAddr,
;;;84     												aBoardLockState->ucState);
;;;85     		return 1;
;;;86     	}
;;;87     	
;;;88     	return 0;
000008  2000              MOVS     r0,#0
;;;89     }
00000a  bd00              POP      {pc}
                  |L4.12|
00000c  7881              LDRB     r1,[r0,#2]            ;83
00000e  7840              LDRB     r0,[r0,#1]            ;83
000010  f7fffffe          BL       SetBoardALockState
000014  2001              MOVS     r0,#1                 ;85
000016  bd00              POP      {pc}
;;;90     
                          ENDP


                          AREA ||i.ReadLockRspDel||, CODE, READONLY, ALIGN=2

                  ReadLockRspDel PROC
;;;115    /*读取锁状态返回处理*/
;;;116    uint16_t ReadLockRspDel(ReadBoardLockStateRsp *aBoardLockState)
000000  7841              LDRB     r1,[r0,#1]
;;;117    {
;;;118    	/*1、要判断是那个块板子的*/
;;;119    	uint8_t uiLoop = 0;
;;;120    	
;;;121    	SetBoardLockState(mdSwitchControl.sAllBoardInfo[aBoardLockState->ucBoardAddr].ucBoardLockState,
000002  eb010281          ADD      r2,r1,r1,LSL #2
000006  eb0201c1          ADD      r1,r2,r1,LSL #3
00000a  4a03              LDR      r2,|L5.24|
00000c  eb020241          ADD      r2,r2,r1,LSL #1
000010  4601              MOV      r1,r0
000012  1c50              ADDS     r0,r2,#1
000014  f7ffbffe          B.W      SetBoardLockState
;;;122    										aBoardLockState);
;;;123    
;;;124    }
;;;125    /*控制卡状态返回处理*/
                          ENDP

                  |L5.24|
                          DCD      ||.bss||

                          AREA ||i.SetBoardALockState||, CODE, READONLY, ALIGN=2

                  SetBoardALockState PROC
;;;70     /*单个锁状态修改更新*/
;;;71     uint16_t SetBoardALockState(uint8_t BoardAddr,uint8_t LockAddr,uint8_t State)
000000  eb000380          ADD      r3,r0,r0,LSL #2
;;;72     {
;;;73     	mdSwitchControl.sAllBoardInfo[BoardAddr].ucBoardLockState[LockAddr] = State;
000004  eb0300c0          ADD      r0,r3,r0,LSL #3
000008  4b03              LDR      r3,|L6.24|
00000a  eb030040          ADD      r0,r3,r0,LSL #1
00000e  4408              ADD      r0,r0,r1
000010  7042              STRB     r2,[r0,#1]
;;;74     	
;;;75     	return 1;
000012  2001              MOVS     r0,#1
;;;76     }
000014  4770              BX       lr
;;;77     /*开锁返回处理命令*/
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      ||.bss||

                          AREA ||i.SetBoardLockState||, CODE, READONLY, ALIGN=1

                  SetBoardLockState PROC
;;;91     /*根据返回状态跟新系统保存的锁状态*/
;;;92     uint16_t SetBoardLockState(uint8_t *ucBoardLockState,ReadBoardLockStateRsp *aBoardLockState)
000000  b570              PUSH     {r4-r6,lr}
;;;93     {
;;;94     	uint8_t uiLoop =0;
;;;95     	uint32_t Temp = 0;
;;;96     	
;;;97     	Temp = ((uint32_t)aBoardLockState->ucState1 * 256 + aBoardLockState->ucState2) * 256 + aBoardLockState->ucState3;
000002  78ca              LDRB     r2,[r1,#3]
000004  788b              LDRB     r3,[r1,#2]
000006  7909              LDRB     r1,[r1,#4]
000008  eb022203          ADD      r2,r2,r3,LSL #8
00000c  eb012202          ADD      r2,r1,r2,LSL #8
;;;98     
;;;99     	/*0-7块板子依次跟新*/
;;;100    	for(uiLoop = 1;uiLoop < BOARD_LOCK_NUM; uiLoop++)
000010  2101              MOVS     r1,#1
;;;101    	{
;;;102    		if((Temp && (0x000001 << (uiLoop - 1))))
;;;103    		{
;;;104    			/*从1开始*/
;;;105    			ucBoardLockState[uiLoop] =  BOARD_LOCK_OPEN_STATE;
000012  2411              MOVS     r4,#0x11
000014  460b              MOV      r3,r1                 ;100
000016  2500              MOVS     r5,#0
                  |L7.24|
000018  b12a              CBZ      r2,|L7.38|
00001a  1e4e              SUBS     r6,r1,#1              ;102
00001c  fa13f606          LSLS     r6,r3,r6              ;102
000020  d001              BEQ      |L7.38|
000022  5444              STRB     r4,[r0,r1]
000024  e000              B        |L7.40|
                  |L7.38|
;;;106    			
;;;107    		}
;;;108    		else
;;;109    		{
;;;110    			ucBoardLockState[uiLoop] =  BOARD_LOCK_CLOSE_STATE;
000026  5445              STRB     r5,[r0,r1]
                  |L7.40|
000028  1c49              ADDS     r1,r1,#1
00002a  b2c9              UXTB     r1,r1                 ;100
00002c  2919              CMP      r1,#0x19              ;100
00002e  d3f3              BCC      |L7.24|
;;;111    		}
;;;112    	}
;;;113    	return 1;
000030  2001              MOVS     r0,#1
;;;114    }
000032  bd70              POP      {r4-r6,pc}
;;;115    /*读取锁状态返回处理*/
                          ENDP


                          AREA ||i.SwitchControlBoardRspDel||, CODE, READONLY, ALIGN=2

                  SwitchControlBoardRspDel PROC
;;;125    /*控制卡状态返回处理*/
;;;126    uint16_t SwitchControlBoardRspDel()
000000  480e              LDR      r0,|L8.60|
;;;127    {
000002  b500              PUSH     {lr}
;;;128    	ReadBoardLockStateRsp *aBoardLockState = NULL;
;;;129    	OpenBoardLockRsp      *aOpenBoardLockRspState = NULL;
;;;130    	
;;;131    	if(mdSwitchControl.sComInfo.RecvMessage[0] != FIND_BOARD_ADDR_HEAD && 
000004  f890109c          LDRB     r1,[r0,#0x9c]  ; mdSwitchControl
000008  2981              CMP      r1,#0x81
00000a  d008              BEQ      |L8.30|
;;;132    		 mdSwitchControl.sComInfo.RecvMessage[0] != OPEN_BOARD_LOCK_HEAD &&
00000c  298a              CMP      r1,#0x8a
00000e  d006              BEQ      |L8.30|
;;;133    		 mdSwitchControl.sComInfo.RecvMessage[0] != READ_BOARD_LOCK_HEAD &&
000010  2980              CMP      r1,#0x80
000012  d004              BEQ      |L8.30|
;;;134    		 mdSwitchControl.sComInfo.RecvMessage[0] != READ_BOARD_PROTCOL_VERSION_HEAD)
000014  2990              CMP      r1,#0x90
000016  d002              BEQ      |L8.30|
;;;135    	{
;;;136    		return -1;/*返回指令不正确*/
000018  f64f70ff          MOV      r0,#0xffff
;;;137    	}
;;;138    	
;;;139    	switch(mdSwitchControl.sComInfo.RecvMessage[0])
;;;140    	{
;;;141    		/*查找板卡地址返回*/
;;;142    		case FIND_BOARD_ADDR_HEAD:break;
;;;143    		/*打开指定锁返回*/
;;;144    		case OPEN_BOARD_LOCK_HEAD:		 
;;;145    				 /*开始后的返回需要及时的修改到状态中*/
;;;146    				aOpenBoardLockRspState = (OpenBoardLockRsp *)&mdSwitchControl.sComInfo.RecvMessage[0];
;;;147    				OpenLockRspDel(aOpenBoardLockRspState);	
;;;148    				break;
;;;149    		/*读取锁状态返回*/
;;;150    		case READ_BOARD_LOCK_HEAD:
;;;151    				aBoardLockState = (ReadBoardLockStateRsp *)&mdSwitchControl.sComInfo.RecvMessage[0];
;;;152    				ReadLockRspDel(aBoardLockState);
;;;153    		/*读取协议版本返回*/
;;;154    		case READ_BOARD_PROTCOL_VERSION_HEAD:break;
;;;155    	}
;;;156    	return 1;
;;;157    }
00001c  bd00              POP      {pc}
                  |L8.30|
00001e  4807              LDR      r0,|L8.60|
000020  309c              ADDS     r0,r0,#0x9c           ;131
000022  2980              CMP      r1,#0x80              ;139
000024  d006              BEQ      |L8.52|
000026  2981              CMP      r1,#0x81              ;139
000028  d006              BEQ      |L8.56|
00002a  298a              CMP      r1,#0x8a              ;139
00002c  d104              BNE      |L8.56|
00002e  f7fffffe          BL       OpenLockRspDel
000032  e001              B        |L8.56|
                  |L8.52|
000034  f7fffffe          BL       ReadLockRspDel
                  |L8.56|
000038  2001              MOVS     r0,#1                 ;156
00003a  bd00              POP      {pc}
;;;158    
                          ENDP

                  |L8.60|
                          DCD      ||.bss||

                          AREA ||i.SwitchControlDel||, CODE, READONLY, ALIGN=2

                  SwitchControlDel PROC
;;;159    /*控制板处理任务*/
;;;160    uint16_t SwitchControlDel()
000000  b510              PUSH     {r4,lr}
;;;161    {
;;;162    	if(mdSwitchControl.sComInfo.WorkFlage & RECV_IS_ING)			/*正在接受*/
000002  4c0b              LDR      r4,|L9.48|
000004  f8940101          LDRB     r0,[r4,#0x101]  ; mdSwitchControl
000008  0781              LSLS     r1,r0,#30
00000a  d50f              BPL      |L9.44|
;;;163    	{
;;;164    		if(mdSwitchControl.sComInfo.WorkFlage & RECV_NEW_DATA)	/*接受到新数据*/
00000c  0741              LSLS     r1,r0,#29
00000e  d50d              BPL      |L9.44|
;;;165    		{
;;;166    			mdSwitchControl.sComInfo.WorkFlage &= ~RECV_IS_ING;/*清楚正在接受*/
000010  f0200002          BIC      r0,r0,#2
000014  f8840101          STRB     r0,[r4,#0x101]
000018  f5047480          ADD      r4,r4,#0x100
;;;167    			//USART_ITConfig(USART1, USART_IT_RXNE, DISABLE);		//关闭接收中断
;;;168    			SwitchControlBoardRspDel();
00001c  f7fffffe          BL       SwitchControlBoardRspDel
;;;169    			mdSwitchControl.sComInfo.WorkFlage &= ~RECV_NEW_DATA;/*清楚正在接受*/
000020  7860              LDRB     r0,[r4,#1]  ; mdSwitchControl
000022  f0200004          BIC      r0,r0,#4
000026  7060              STRB     r0,[r4,#1]
;;;170    			mdSwitchControl.sComInfo.RecvCount = 0;
000028  2000              MOVS     r0,#0
00002a  7020              STRB     r0,[r4,#0]
                  |L9.44|
;;;171    			//USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);		//关闭接收中断
;;;172    		}
;;;173    	}
;;;174    	return 1;
00002c  2001              MOVS     r0,#1
;;;175    }
00002e  bd10              POP      {r4,pc}
;;;176    
                          ENDP

                  |L9.48|
                          DCD      ||.bss||

                          AREA ||i.SwitchControlInit||, CODE, READONLY, ALIGN=2

                  SwitchControlInit PROC
;;;198    /*控制板卡初始化*/
;;;199    uint8_t SwitchControlInit()
000000  b508              PUSH     {r3,lr}
;;;200    {
;;;201    	memset(&mdSwitchControl, 0, sizeof(SwitchControl));
000002  f44f7181          MOV      r1,#0x102
000006  480f              LDR      r0,|L10.68|
000008  f7fffffe          BL       __aeabi_memclr
;;;202    	
;;;203    	USARTInit(SWITCH_BOARD_USAET, SWITCH_BOARD_BUAD, SWITCH_BOARD_PORT, SWITCH_BOARD_TXD, SWITCH_BOADR_RXD);
00000c  f44f6080          MOV      r0,#0x400
000010  1043              ASRS     r3,r0,#1
000012  9000              STR      r0,[sp,#0]
000014  4a0c              LDR      r2,|L10.72|
000016  f44f5116          MOV      r1,#0x2580
00001a  480c              LDR      r0,|L10.76|
00001c  f7fffffe          BL       USARTInit
;;;204    	
;;;205    	
;;;206    	mdSwitchControl.sAllBoardInfo[0].ucBoardAddr =0x01;
000020  4808              LDR      r0,|L10.68|
000022  2101              MOVS     r1,#1
000024  7001              STRB     r1,[r0,#0]
;;;207    	mdSwitchControl.sAllBoardInfo[1].ucBoardAddr =0x02;
000026  2102              MOVS     r1,#2
000028  7681              STRB     r1,[r0,#0x1a]
;;;208    	mdSwitchControl.sAllBoardInfo[2].ucBoardAddr =0x03;
00002a  2103              MOVS     r1,#3
00002c  f8801034          STRB     r1,[r0,#0x34]
;;;209    	mdSwitchControl.sAllBoardInfo[3].ucBoardAddr =0x04;
000030  2104              MOVS     r1,#4
000032  f880104e          STRB     r1,[r0,#0x4e]
;;;210    	mdSwitchControl.sAllBoardInfo[4].ucBoardAddr =0x05;
000036  2105              MOVS     r1,#5
000038  f8801068          STRB     r1,[r0,#0x68]
;;;211    	
;;;212    	mdUsart.USART1_s.USARTUserDel = SwitchControlRecvCmdDel;/*注册回调函数*/
00003c  4905              LDR      r1,|L10.84|
00003e  4804              LDR      r0,|L10.80|
000040  60c8              STR      r0,[r1,#0xc]  ; mdUsart
;;;213    }
000042  bd08              POP      {r3,pc}
                          ENDP

                  |L10.68|
                          DCD      ||.bss||
                  |L10.72|
                          DCD      0x40010800
                  |L10.76|
                          DCD      0x40013800
                  |L10.80|
                          DCD      SwitchControlRecvCmdDel
                  |L10.84|
                          DCD      mdUsart

                          AREA ||i.SwitchControlRecvCmdDel||, CODE, READONLY, ALIGN=2

                  SwitchControlRecvCmdDel PROC
;;;177    
;;;178    uint16_t SwitchControlRecvCmdDel(uint16_t arg1,uint16_t arg2)
000000  490d              LDR      r1,|L11.56|
;;;179    {
;;;180    	mdSwitchControl.sComInfo.WorkFlage |= RECV_IS_ING;	/*正在接受*/
000002  f8912101          LDRB     r2,[r1,#0x101]  ; mdSwitchControl
000006  f0420202          ORR      r2,r2,#2
00000a  f8812101          STRB     r2,[r1,#0x101]
;;;181    	
;;;182    	mdSwitchControl.sComInfo.RecvMessage[mdSwitchControl.sComInfo.RecvCount] = arg1;
00000e  f8913100          LDRB     r3,[r1,#0x100]  ; mdSwitchControl
000012  f101029c          ADD      r2,r1,#0x9c
000016  5498              STRB     r0,[r3,r2]
;;;183    	
;;;184    	mdSwitchControl.sComInfo.RecvCount++;
000018  f8910100          LDRB     r0,[r1,#0x100]  ; mdSwitchControl
00001c  1c40              ADDS     r0,r0,#1
00001e  b2c0              UXTB     r0,r0
000020  f8810100          STRB     r0,[r1,#0x100]
;;;185    	
;;;186    	if(mdSwitchControl.sComInfo.RecvCount > 2)
000024  2802              CMP      r0,#2
000026  d905              BLS      |L11.52|
;;;187    	{
;;;188    		mdSwitchControl.sComInfo.WorkFlage |= RECV_NEW_DATA;
000028  f8910101          LDRB     r0,[r1,#0x101]  ; mdSwitchControl
00002c  f0400004          ORR      r0,r0,#4
000030  f8810101          STRB     r0,[r1,#0x101]
                  |L11.52|
;;;189    	}
;;;190    	if(mdSwitchControl.sComInfo.RecvCount > RECV_BUFF_LEN)
;;;191    	{
;;;192    		/*未处理*/
;;;193    	}
;;;194    	return 1;
000034  2001              MOVS     r0,#1
;;;195    }
000036  4770              BX       lr
;;;196    
                          ENDP

                  |L11.56|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  mdSwitchControl
                          %        258
